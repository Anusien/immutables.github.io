---
title: 'Get started!'
layout: page
---

{% capture v %}2.0{% endcapture %}
{% capture g %}18.0{% endcapture %}
{% capture depUri %}http://search.maven.org/#artifactdetails|org.immutables{% endcapture %}

## Prerequisites

Java 7 or higher is required to run _Immutables_ annotation processor.
Guava v12 or higher is required.

Add required dependencies for basic immutable object generation:

- [org.immutables:value-standalone:{{v}}]({{ depUri }}|value-standalone|{{ v }}|jar)
  + Compile-only annotation processing tool. All in one artifact: annotations, processor with repackaged embedded depencies. Declare it in "provided" scope to prevent propagation of this artifact to runtime.

In _addition_ to the standalone artifact, annotation API jar (to read javadocs in IDE) with transitive Guava dependency could be added if needed.

- [org.immutables:value:{{v}}]({{ depUri }}|value|{{ v }}|jar)
  + Compile annotations and Guava v{{g}} as transitive dependency.

Snippet of maven dependencies:

```xml
<dependency>
  <groupId>org.immutables</groupId>
  <artifactId>value</artifactId>
  <version>{{ v }}</version>
</dependency>
<dependency>
  <groupId>org.immutables</groupId>
  <artifactId>value-standalone</artifactId>
  <version>{{ v }}</version>
  <scope>provided</scope>
  <optional>true</optional>
</dependency>
```

_Immutables_ annotation processor runs under any Java build tool that uses `javac` as compiler backend (given annotation processing is not disabled in build tool configuration).
_Eclipse JDT compiler_ (ECJ) also supports this annotation processor. See [Using annotation processor in IDE](/apt.html).

## Create immutable object

Assuming that required dependencies were added, create a abstract class with abstract accessor methods. You can do this with interfaces or even annotations (`@interface`)

```java
package info.sample;

import java.util.List;
import java.util.Set;
import org.immutables.value.Value;

@Value.Immutable
public abstract class FoobarValue {
  public abstract int foo();
  public abstract String bar();
  public abstract List<Integer> buz();
  public abstract Set<Long> crux();
}
```

After this moment you can compile and use generated immutable implementation.

```java
package info.sample;

import java.util.List;

public class FoobarValueMain {
  public static void main(String... args) {
    FoobarValue value = ImmutableFoobarValue.builder()
        .foo(2)
        .bar("Bar")
        .addBuz(1, 3, 4)
        .build(); // FoobarValue{foo=2, bar=Bar, buz=[1, 3, 4], crux={}}

    int foo = value.foo(); // 2

    List<Integer> buz = value.buz(); // ImmutableList.of(1, 3, 4)
  }
}
```
Congratulations! Done!
See [sample generated code](/generated.html) for an example of what kind of code is being generated by processor.

Even basic immutable class generation has a lot more tricks to show, check out [reference](/immutable.html)!

