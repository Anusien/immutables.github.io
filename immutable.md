---
title: 'Immutable objects reference'
layout: page
---

Concepts
--------
The core of _org.immutables_ is modelling. Fine modelling is at heart of creating good application,
services and good design in general. We feel proud to fill a gap in modelling in the Java language,
where usage of JavaBeans just insufficient.

* Immutable object constructed once, in consistent state and can be safely shared
  - Will fail if attribute is missing
  - No sneaky modification when passed to other code
* Immutable objects are naturally thread-safe and can be safely shared among threads
  - No excessive copying
  - No excessive synchronization
* Object definitions are pleasant to write and read
  - No boilerplate setter and getters
  - No ugly IDE-generated `hashCode`, `equals` and `toString` methods that are stored in source control.

As shown on [getting started!](/gettingstarted.html) page:
you create an **abstract value class** then add annotation to generate **immutable implementation class**!
See [sample generated code](/generated.html) for an example of what kind of code is being generated by processor.

We use [Guava](https://code.google.com/p/guava-libraries) as utility library in generated classes,
but also employ modern API style popularized by "Effectice Java, Second Edition" book and Guava Library.

It's great to provide solution that do not require compiler hacks or companion languages,
no matter how sophisticated they are. Annotation processing that is part `javac` allows for useful
code generation. Classes are being generated during compilation are not stored in source control,
however, generated sources are easily inspectable if needed. Generated code extends user written code,
but never mixed in one file!

While it may seem that usage _org.immutables_ may result in some sort of [anemic domain model](http://www.martinfowler.com/bliki/AnemicDomainModel.html),
_this impression is false_, as we see great benefits of proper domain modelling, but we need solid building blocks - value objects,
a smart data objects, immutable values that have methods that compute other values and reduce complexity of services and entities.
Other aspect of modern modelling is representating state of a system and domain entities as sequences of _events_ or _snapshots_.
The techniques, like [event sourcing](http://martinfowler.com/eaaDev/EventSourcing.html) employs
benefits of immutable object graphs, allow sub-graphs to be shared between snapshots, transform system states,
or even reconstruct full system state at some point in time.
For that kind of systems we just made writing immutable object a whole lot easier.

* Read "Item 15: Minimize mutability" [Effectice Java, Second Edition](http://www.amazon.com/Effective-Java-Edition-Joshua-Bloch/dp/0321356683)
  book for classic summary on immutability
* Watch ["Power Use of Value Objects" presentation](http://www.infoq.com/presentations/Value-Objects-Dan-Bergh-Johnsson) for examples of how useful value objects are.
* Watch ["Simple made easy" presentation](http://www.infoq.com/presentations/Simple-Made-Easy)
  about some insights on simplicity of immutability.

### Base terminology

+ **org.immutables**
  - Named following reverse-domain-name java package naming convention, _org.immutables_ is:
      - In most broadest sense it is open source software project on [Github immutables/org.immutables](https://github.com/immutables/org.immutables),
        whose documentation you are currently reading.
      - The annotation processor and corresponding libraries produced by this project.

+ **Abstract value class**
  - Manually written class that defines value class and is annotated
    with `org.immutable.annotation.GenerateImmutable` annotation. May contain **attributes** and other metadata,
    as well as regular java methods and fields if needed. It is strongly recommended to not introduce
    observable mutable state in abstract value class. Abstract value classes are used as the source
    model for generated code.

+ **Attribute**
  - In context of **abstract value class**, attribute is zero argument, non-`void` java method that declares
    accessor for the auto-generated fields. Attribute value cannot be changed after object is created.
    It is intentionally named "attribute" to distinguish from "field" and JavaBean "property" and to draw similarity
    with annotation type attributes. To make code less cluttered, no annotation required on abstract accessor method to
    became attribute, however some attributes, such as attributes with default values, will non-`abstract` method and
    thus will require annotation to distinguish from regular method.

+ **Immutable implementation class**
  - Generated `public final class` that extends manually-written **Abstract value class**
    and implements all declared accessor methods as well as supporting fields, methods, constructors and builder class.
    This is primary, but not the only one source code artifact, generated by _org.immutables_ annotation processor.

Features
--------

-----
### Builder
Builders are generated

-----
### Constructors

----
### Collection and Map attributes

----
### Optional attributes

-----
### Copying with modified attributes

-----
### Default attributes

-----
### Derived attributed

-----
### Singleton instances

-----
### Instance interning

-----
### Precomputed hashCode

-----
### Custom `toString`, `hashCode` and `equals` method

-----
### Modifiable companion








