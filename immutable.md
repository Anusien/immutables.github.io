---
title: 'Immutable objects'
layout: page
---

Introduction
------------
The core of _Immutables_ is modeling. Fine modelling is at heart of creating good application,
services and good design in general. We feel proud to fill a gap in modelling in the Java language,
where usage of JavaBeans just insufficient.

* Immutable object constructed once, in consistent state and can be safely shared
  - Will fail if mandatory attribute is missing
  - No sneaky modification when passed to other code
* Immutable objects are naturally thread-safe and can be safely shared among threads
  - No excessive copying
  - No excessive synchronization
* Object definitions are pleasant to write and read
  - No boilerplate setter and getters
  - No ugly IDE-generated `hashCode`, `equals` and `toString` methods that are stored in source control.

As shown on [get started](/getstarted.html) page:
you create an **abstract value class** then add annotation to generate **immutable implementation class**!
See [sample generated code](/generated.html) for an example of what kind of code is being generated by processor.

_Immutables_ have been in development for over two years counting from it's earliest prototypes.
Core of the toolkit is being successfully used in production:
it was used for development airline inventory system components, travel deals aggregators and other application
that take advantages of efficient in-memory storage and concurrent computations on JVM.

[Guava](https://code.google.com/p/guava-libraries) is used as utility library for generated classes,
but in addition we employ effective API style popularized by "Effective Java, Second Edition" book and Guava Library.
Usage of `null` as attribute values is rigorously prohibited ([Using and avoiding null explained](https://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained)).

It's great to provide solution that do not require compiler hacks or companion languages,
no matter how sophisticated they are. Annotation processing that is part standard java compiler allows for useful
code generation. Classes are being generated during compilation are not stored in source control,
however, generated sources are easily inspectable if needed. Generated code extends user written code,
but never mixed in one file!

It may seem that usage _Immutables_ may result in some sort of [anemic domain model](http://www.martinfowler.com/bliki/AnemicDomainModel.html),
however, this impression is false and we see great benefits of proper domain modelling. But we need solid building blocks — value objects,
a [smart data](#smart-data) objects, immutable values that have methods that compute other values and reduce complexity of services and entities.
Other aspect of modelling is representation of system state and domain entities as sequences of _events_ or _snapshots_.
The techniques like [event sourcing](http://martinfowler.com/eaaDev/EventSourcing.html) employs
benefits of immutable object graphs, allow sub-graphs to be shared between snapshots, transform system states,
or even reconstruct full system state at some point in time.
For that kind of systems we just made writing immutable objects a whole lot easier.

* Read "Item 15: Minimize mutability" [Effective Java, Second Edition](http://www.amazon.com/Effective-Java-Edition-Joshua-Bloch/dp/0321356683)
  book for classic summary on immutability
* Watch ["Power Use of Value Objects" presentation](http://www.infoq.com/presentations/Value-Objects-Dan-Bergh-Johnsson)
  for examples of how useful value objects are.
* Watch ["Simple made easy" presentation](http://www.infoq.com/presentations/Simple-Made-Easy)
  about some insights on simplicity of immutability.

--------
Concepts
--------

<a name="abstract-value"></a>
### Abstract value class
Abstract value class — manually written class that defines value type and is annotated
with `org.immutable.annotation.GenerateImmutable` annotation. May contain [attributes](#attributes) and other meta-data,
as well as regular java methods (and fields if needed). It is strongly recommended to not introduce
visible mutable state in abstract value class. Abstract value classes are used as the source
model for generated code. [Get started!](/getstarted.html).

<a name="attributes"></a>
### Attributes
An attribute hold value which cannot be changed after object is created.
It is intentionally named "attribute" to distinguish it from "field" and JavaBean "property" and also to draw similarity
with annotation attributes.
It is defined by accessor method: zero argument, non-`void` java method.
No annotation required on abstract accessor method to became attribute, however some attributes,
such as attributes with [default values](#default-attribute)
are non-`abstract` methods that have body that computes value,
thus such accessors require special annotation to distinguish from regular method.

### Immutable implementation class
[Generated](/generated.html) `final` `class` that extends manually-written [abstract value class](#abstract-value)
and implements all declared accessor methods as well as supporting fields, methods, constructors and builder class.
Immutable implementation class implements abstract attribute accessors
for scalar primitive and object reference types, special support provided for [collection attributes](#collection)
and some other types.
`Object`'s methods `equals`, `hashCode` and `toString()` are overridden an fully dependent on attribute values
rather that object identity.
Immutable implementation class is primary, but not the only source code artifact
generated by _Immutables_ annotation processor.

--------
Features
--------

<a name="builder"></a>
### Builder
By default, builders are generated for each immutable implementation class.
Builders enable expressive construction of object using named attribute initializers,
and generally builders compensates lack of named and optional constructor arguments in Java language.

+ To create builder invoke static `builder()` method on generated immutable implementation class
+ Invoke attribute initializer methods to set attributes
+ Call `build()` methods to construct immutable instance after attributes are initialized.
  Build method will fail if any mandatory attribute is omitted.

```java
// builder methods illustrated
ImmutableObject.builder()
    .attribute1(1442)
    .anotherAttribute(true)
    .addListAttribute("a")
    .addListAttribute("b")
    .addAllSetAttribute(Arrays.asList("1", "2"))
    .optionalAttribute("value")
    .putMapAttribute(key, value)
    .build();
```

If builder became redundant in presence of [constructor](#constructor), you can disable generation of builder
using `@GenerateImmutable(builder = false)` annotation parameter.

In advanced usage of builders you will want to pass builders that builds different types of objects but conform to the
same interface, akin to original [Builder pattern](http://en.wikipedia.org/wiki/Builder_pattern).
It is archivable by declaring static nested class named "Builder",
which will be extended by generated builder.

```java
interface Weapon {
  // we are peaceful: our weapon won't get any fire methods )
}

interface WeaponBuilder {
  // Generated builders will implement this method
  // It is compatible with signature of generated builder methods where
  // return type is narrowed to Railgun or RocketLauncher
  Weapon build();
}

@GenerateImmutable
public abstract class Railgun implements Weapon {
  public abstract class Builder implements WeaponBuilder {}
}

@GenerateImmutable
public abstract class RocketLauncher implements Weapon {
  public abstract class Builder implements WeaponBuilder {}
}

class Builders {
  void buildAndThrowAwayWeapon(WeaponBuilder builder) {
    Weapon throwawayWeapon = builder.build();
  }
  
  void exercise() {
    buildAndThrowAwayWeapon(ImmutableRailgun.builder());
    buildAndThrowAwayWeapon(ImmutableRocketLauncher.builder());
  }
}
```

Explicitly declared "Builder" could specify all needed `extends` or `implements` declarations
as well as it could have convenience methods that will show up on immutable object builder.
However, special care should be taken in order to maintain structural compatibility of
declared builder supertype and generated builders, otherwise compile error will occur in generated code.

<a name="constructor"></a>
### Constructor method
As an alternative to builder, it is possible to provide concise "constructor" factory method.
Constructor will be available as `static` method named `of` on immutable implementation class.

In order to generate constructor method, certain attributes should be annotated
with `org.immutables.annotation.GenerateConstructorParameter` annotation.

```java
@GenerateImmutable
public abstract class HostWithPort {
  @GenerateConstructorParameter(order = 0)
  public abstract String hostname();
  @GenerateConstructorParameter(order = 1)
  public abstract int port();
}
...
HostWithPort hostWithPort = ImmutableHostWithPort.of("localhost", 8081);

boolean willBeTrue = hostWithPort.equals(
    ImmutableHostWithPort.builder()
        .hostname("localhost")
        .port(8081)
        .build());
```

If there's more that one constructor parameter it is advised to put `order` annotation attribute to make constructor
parameter order deterministic across java compilers that may not honor source order.
See [JSR 269: Clarify ordering requirements...](http://bugs.sun.com/view_bug.do?bug_id=6884227). 

**Possible problems**

+ If not all mandatory attributes are marked as `@GenerateConstructorParameter`
  - Compilation error in the generated code: not all final fields were initialized in constructor
+ If `order` attribute on `@GenerateConstructorParameter` is omitted, then ECJ could generate code
  that differs from javac output, see [bug 300408](https://bugs.eclipse.org/bugs/show_bug.cgi?id=300408). 
  - could result in compile error in code that calls generated factory method due to misplaced parameters.

<a name="collection"></a>
### Collection and Map attributes

Following collection types enjoy built-in support for convenient usage:

+ `java.util.List<T>`

+ `java.util.Set<T>`

+ `java.util.Map<K, V>`

Collection attributes are backed by Guava immutable collections,
moreover, `java.util.Set` and `java.util.Map` with `enum` keys
are backed by efficient `EnumSet` and `EnumMap` implementations.

Any container attribute is non mandatory to specify using builder.
This behavior could be altered in some ways, for example, see [Precondition check method](#check-method)

[Builders](#builder) have special methods to initialize collection attributes:

+ for set or list attribute named `Foo` where elements are of type `T`
  - `addFoo(T)`
  - `addAllFoo(Iterable<? extends T>)`
  - `clearFoo()`
  
+ for map attribute named `Bar` where keys are of type `K` and values of type `V`
  - `putBar(K, V)`
  - `putBar(Map.Entry<? extends K, ? extends V>)`
  - `putAllBar(Map<? extends K, ? extends K>)`
  - `clearBar()`
  
Someone may ask: why other kinds of containers is not supported in the same way,
for example `java.lang.Iterable`, `java.util.Collection` or `java.util.NavigableSet`?
That's because those other containers are either too-generic or too-specific for the purposes of immutable object modelling.
The nice side of this is that any type is supported as attribute value, and while there's no any kind of magic support,
other container types are still usable:

```java
@GenerateImmutable
public abstract class DoItYourselfContainer {
   public abstract Iterable<String> iterable();
   public abstract NavigableSet<Integer> sortedSet();
}
...
ImmutableDoItYourselfContainer.builder()
    .iterable(ImmutableSet.of("a", "b", "c"))
    .sortedSet(ImmutableSortedSet.of(1, 2, 3, 4))
    .build();
```

<a name="optional"></a>
### Optional attributes

Attributes declared with return type of `com.google.common.base.Optional<T>`
defines logically [optional](https://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained#Optional)
attribute of type `T`. 

Optional value could be omitted when building object, and will default to `Optional.absent()`.
Generated builders have special initializer for optional attributes:

+ for optional attribute named `opt` where elements are of type `T`
  - `opt(T)` sets present value for T
  - `opt(Optional<T>)` specifies present or absent

<a name="default-attribute"></a>
### Default attributes

We could allow attribute to have some default value if it was omitted with [builder](#builder).
To declare default attribute, create non-abstract attribute initializer method and annotate it with
`org.immutables.annotation.GenerateDefault`. If value was omitted during construction, this initializer method will be called to
retrieve default value of the attribute and store. Consequently, accessor method will return stored value.

```java
@GenerateImmutable
public abstract class PlayerInfo {

  @GenerateConstructorParameter
  public abstract long id();
  
  @GenerateDefault
  public String name() {
    return "Anonymous_" + id(); 
  }
  
  @GenerateDefault
  public int gamesPlayed() {
    return 0; 
  }
}
...

PlayerInfo veteran = ImmutablePlayerInfo.builder()
    .id(1)
    .name("Fiddler")
    .gamesPlayed(99)
    .build();

PlayerInfo anonymous44 = ImmutablePlayerInfo.of(44);

String name = anonymous44.name(); // Anonymous_44
``` 

Default attribute method's body should not refer to any other derived or default attribute.
Otherwise construction will be broken due to unspecified initialization order.
It's only guaranteed that all attributes with abstract accessors will be initialized before
default and derived attributes, and therefore could be safely referred in initializers.

**Possible problems**

+ Unspecified result if initializer method body refers to non-abstract attribute accessor.

<a name="derived-attribute"></a>
### Derived attributes
Derived attributes may be read from immutable instance, but it could not be set. It's value is usually derived
from other attributes.

To declare derived attribute, create non-abstract attribute initializer method and annotate it with
`org.immutables.annotation.GenerateDerived`. Similarly to [default attributes](#default-attribute),
body of the method should compute and return value of an attribute. Derived attributes acts much like
regular methods that simply compute and return some value, but with single important difference:
value of derived attribute computed once and stored to a field (in the end of object construction).

```java
@GenerateImmutable
public abstract class Order {

  public abstract List<Item> items();

  @GenerateDerived
  public int totalCount() {
    int count = 0;

    for (Item i : items())
      count += i.count();
      
    return count;
  }
}

Order order = ImmutableOrder.builder()
    .addItems(Item.of("item1", 11))
    .addItems(Item.of("item2", 22))
    .build();

// total count will be already computed
int totalCount33 = order.totalCount();
```

As with [default attributes](#default-attribute), derived attribute method's
body should not refer to any other derived or default attribute.

**Possible problems**

+ Unspecified result if initializer method body refers to non-abstract attribute accessor. 

<a name="lazy-attribute"></a>
### Lazy attributes
Lazy attributes are initializer methods that computes value lazily once.

To declare lazy attribute, create non-abstract attribute initializer method and annotate it with
`org.immutables.annotation.GenerateLazy`. Similarly to [derived attributes](#derived-attribute),
body of the method should compute and return value of an attribute.
Derived attributes acts much like regular methods, but compute value on first access and subsequently
return same memoized value.

**Be warned**: _lazy attributes do not take part in equals and hashCode computation!_

```java
@GenerateImmutable
public abstract class Order {

  public abstract List<Item> items();

  @GenerateLazy
  public int totalCost() {
    int cost = 0;

    for (Item i : items())
      cost += i.count() * i.price();

    return cost;
  }
}

Order order = ImmutableOrder.builder()
    .addItems(Item.of("item1", 11, 1))
    .addItems(Item.of("item2", 22, 2))
    .build();

// total cost will be computed now
int lazilyComputedCost = order.totalCost();
```

Lazy values are thread safe and will be computed once and only once regardless of race condition.

Unlike to [default](#default-attribute) or [derived](#derived-attributes) attributes,
body of the lazy attribute accessor method could refer to any attribute.

That said, restrictions still apply to call only abstract accessors from default or derived attributes.
Do not refer to lazy values from default or derived attributes to avoid issues.
Calling lazy attribute from derived or default is _not always safe_,
it will make no sense as it will made lazy value an eagerly computed, moreover, if lazy value is in turn uses
in computation one of those default or derived attribute, then it may found it uninitialized.

<a name="check-method"></a>
### Precondition check method
One of the core advantages of immutable objects is the fact that an immutable object will be constructed with
proper attribute values in _consistent state_ and _never changes_ afterwards.
So often arises a need to check attribute values or combination of attribute values (cross validation)
for correctness.

Given there's no hand-written constructor in a immutable implementation class,
you can write `protected` method annotated with `@GenerateCheck` and throw runtime exceptions if precondition failed.

```java
@GenerateImmutable
public abstract class NumberContainer {
  public abstract List<Number> nonEmptyNumbers();
  
  @GenerateCheck
  protected void check() {
    Preconditions.checkState(!nonEmptyNumbers().isEmpty(),
        "'nonEmptyNumbers' should have at least one number");
  }
}
...
// will throw IllegalStateException("'nonEmptyNumbers' should have at least one number")
ImmutableNumberContainer.builder().build();
```

However, one should notice how this differs from other kinds of object state validation
where object may be constructed with some values and later validated for correctness
regarding business rules in some context. Precondition checking should not be used to validate against such rules,
but to preserve consistency and guarantee that instances will be usable.

Precondition check methods runs when immutable object _instantiated and all attributes are initialized_,
but _before returned to caller_. Any instance that failed precondition
check is unreachable to caller due to runtime exception.

### Singleton instances

It is easy to create "empty" or "default" instances that will be singletons.
Use `@GenerateImmutable(singleton = true)` annotation parameter to generate singleton instances, use concise `of()`
factory method to obtain singleton instance.

```java
@GenerateImmutable(singleton = true)
public abstract class Data {
  public abstract Set<String> chunks();
}

...
boolean willBeTrue =
    ImmuableData.of() == ImmuableData.of();
// true

boolean willBeTrueAlso =
    ImmuableData.of().chunks().isEmpty();
// true
```

Abstract value class should not have any mandatory attributes, otherwise generation of singletons will not be possible.
You can make attributes non-mandatory by using [default attributes](#default-attribute).

As it stands, empty singleton instances could be combined with builders and constructors as long
as all attributes are non-mandatory. But if there should be one
and _only one_ instance of particular immutable type, following recipe will do:

+ Use `singleton = true` and `builder = false` with `@GenerateImmutable` annotation
+ Do not use any `@GenerateConstructorParameter` on attributes 

```java
@GenerateImmutable(singleton = true, builder = false)
public abstract class Singleton {
  // Limit constructor accessibility to a package
  Singleton() {}
}

...
Singleton singleInstance = ImmutableSingleton.of();
```

**Possible problems**

+ If abstract value class contains mandatory attributes
  - Compilation error for the generated code: all final fields should be initialized in constructor

<a name="interning"></a>
### Instance interning
There are cases when number of values of certain type expected to be finite and
measurable performance improvements may be gained by interning those instances.

If all you need is to _strongly_ intern all instances of particular value class — _Immutables_ just does that for you.
Use `@GenerateImmutable(interned = true)` annotation parameter to enable strong interning:

+ Any object returned by builder or constructor will be interned and "canonical" instance returned 
+ `equals` will be short-circuited to object reference equality.

There's support only for strong interning:
soft-reference and weak-reference interning as well as any forms of partial range interning were left out
to be implemented externally.

<a name="prehashed"></a>
### Precomputed hashCode
If immutable object have a lot of attributes or attributes may contain reasonably large
object graphs, then it may become inefficient to recompute `hashCode` value again and again
when used extensively with hashtables.
For such cases, hash code may be precomputed on construction and stored for fast retrieval.
Just use `@GenerateImmutable(prehashed = true)` annotation parameter to enable hash computing in advance.

### Customize toString, hashCode and equals
It's quite easy to customize generated `toString`, `hashCode` and `equals` methods,
in fact it is as easy as just implement them yourself in abstract value class.
_Immutables_ processor will not override such manual methods with generated ones. 

```java
@GenerateImmutable
public abstract class OmniValue {

  @Override
  public boolean equals(Object object) {
    return object instanceof OmniValue;
  }
  
  @Override
  public int hashCode() {
    return 1;
  }

  @Override
  public String toString() {
    return "OmniValue{*}";
  }
}

boolean willBeTrue =
    ImmutableOmniValue.builder().build()
        .equals(new OmniValue() {});
```

Pleasant thing to note is that such manually written `equals` and `hashCode` methods will work
fine with [instance interning](#interning) and [precomputed hashCode](#prehashed) features!

It is deemed to be redundantly to note, but you should implement `equals`
and `hashCode` correctly and only if you a know what you are doing.

### Modifiable companion
See [@GenerateModifiable](https://github.com/immutables/org.immutables/blob/master/annotation/src/org/immutables/annotation/GenerateModifiable.java)

--------
Patterns
--------
This section contains common patterns and recipes using _Immutables_
that are useful but not actually features by themselves.

### Expressive factory methods
There were some feature requests to customize names of constructor method and, in addition, provide construction hooks.
We focused on two interconnected needs:

+ Construct object with some values that are different than factory method parameters, but derived from those parameters.
+ Give descriptive name to factory method to highlight how parameters will be used to construct object.

Having considered special annotation parameters and hook-methods,
we eventually came up with... nothing. This, surprisingly, solves the problem and requires no features: simply declare factory methods
on abstract value class and forward calls to constructor method of immutable implementation class.

```java
@GenerateImmutable
public abstract class Point {
  @GenerateConstructorParameter(order = 0)
  public abstract double x();
  @GenerateConstructorParameter(order = 1)
  public abstract double y();
  
  public static Point origin() {
    return ImmutablePoint.of(0, 0);
  }
  
  public static Point of(double x, double y) {
    return ImmutablePoint.of(x, y);
  }
  
  public static Point fromPolar(double r, double t) {
    return ImmutablePoint.of(r * Math.cos(t), r * Math.sin(t));
  }
}
```

You may also want to use forwarding factory method to hide implementation class from a surface of abstract
value class interface. In example above, notice how usage of `ImmutablePoint` is not leaking through `Point`'s public interface. 

<a name="smart-data"></a>
### Smart data
Immutable objects acts very well in role of a "smart data": in addition to pure data container, value also carries
domain specific knowledge and computation capability. While services and entities orchestrate execution of business logic,
value objects handle computations that are specific to problem domain, but agnostic to business context.

```java
@GenerateImmutable
public abstract class OriginDestination {
  @GenerateConstructorParameter(order = 0)
  public abstract Airport origin();
  @GenerateConstructorParameter(order = 1)
  public abstract Airport destination();

  public boolean isDomestic() {
    return origin().country().equals(destination().country());
  }
  
  public boolean isCrossCityTransit() {
    return origin().city().equals(destination().city());
  }
  
  public OriginDestination reverse() {
    return ImmutableOriginDestination.of(destination(), origin());
  }
  ...
}
```
Go ahead! Enrich value objects with methods that compute values — push computation complexity to the right place!

### Protected attributes
Particular attributes may become redundant from standpoint of public interface of abstract value class,
`protected` visibility may help to hide attribute from API consumers, however it is still be exposed on builders and as
constructor parameters.

```java
@GenerateImmutable
public abstract class Name {
  @GenerateConstructorParameter
  protected abstract String value(); 
  
  public String toString() {
    return value();
  }
  
  public static Name of(String value) {
    return ImmutableName.of(value);
  }
}
...

Name name = Name.of("The Rose");
String value = name.toString();
// "The Rose"
```

### Null-Object pattern in attribute values
As an alternative to using `Optional<T>` attributes — [null-object pattern](http://en.wikipedia.org/wiki/Null_Object_pattern) could be used.
This requires nothing special from _Immutables_, just use [default attributes](#default-attribute)

```java
public enum Stars {
  NONE, ONE, TWO, THREE, FOUR, FIVE;
}

@GenerateImmutable
public abstract class Hotel {
  @GenerateDefault
  public Stars stars() {
    return Stars.NONE;
  }
}
```  

-----------
Limitations
-----------
Some features are not implemented due to lack of time or interest,
while other features were consciously rejected.
Some features were implemented with a basic, unoptimized solution.
Here mentioned several limitation and not implemented features.

- Only top level abstract classes supported as abstract value classes.

- Default and derived attributes cannot reliably refer to any other default or derived attribute.

- Abstract value class could not be parameterized with type variables,
  however it could extend or implement parameterized type when actual types supplied.
  
- _Any other things that Immutables doesn't do_
