---
title: 'Immutable objects reference'
layout: page
---

Concepts
--------
The core of _org.immutables_ is modelling. Fine modelling is at heart of creating good application,
services and good design in general. We feel proud to fill a gap in modelling in the Java language,
where usage of JavaBeans just insufficient.

* Immutable object constructed once, in consistent state and can be safely shared
  - Will fail if attribute is missing
  - No sneaky modification when passed to other code
* Immutable objects are naturally thread-safe and can be safely shared among threads
  - No excessive copying
  - No excessive synchronization
* Object definitions are pleasant to write and read
  - No boilerplate setter and getters
  - No ugly IDE-generated `hashCode`, `equals` and `toString` methods that are stored in source control.

As shown on [getting started!](/gettingstarted.html) page:
you create an **abstract value class** then add annotation to generate **immutable implementation class**!
See [sample generated code](/generated.html) for an example of what kind of code is being generated by processor.

We use [Guava](https://code.google.com/p/guava-libraries) as utility library in generated classes,
but also employ modern API style popularized by "Effectice Java, Second Edition" book and Guava Library.

It's great to provide solution that do not require compiler hacks or companion languages,
no matter how sophisticated they are. Annotation processing that is part `javac` allows for useful
code generation. Classes are being generated during compilation are not stored in source control,
however, generated sources are easily inspectable if needed. Generated code extends user written code,
but never mixed in one file!

While it may seem that usage _org.immutables_ may result in some sort of [anemic domain model](http://www.martinfowler.com/bliki/AnemicDomainModel.html),
_this impression is false_, as we see great benefits of proper domain modelling, but we need solid building blocks - value objects,
a smart data objects, immutable values that have methods that compute other values and reduce complexity of services and entities.
Other aspect of modern modelling is representating state of a system and domain entities as sequences of _events_ or _snapshots_.
The techniques, like [event sourcing](http://martinfowler.com/eaaDev/EventSourcing.html) employs
benefits of immutable object graphs, allow sub-graphs to be shared between snapshots, transform system states,
or even reconstruct full system state at some point in time.
For that kind of systems we just made writing immutable object a whole lot easier.

* Read "Item 15: Minimize mutability" [Effectice Java, Second Edition](http://www.amazon.com/Effective-Java-Edition-Joshua-Bloch/dp/0321356683)
  book for classic summary on immutability
* Watch ["Power Use of Value Objects" presentation](http://www.infoq.com/presentations/Value-Objects-Dan-Bergh-Johnsson)
  for examples of how useful value objects are.
* Watch ["Simple made easy" presentation](http://www.infoq.com/presentations/Simple-Made-Easy)
  about some insights on simplicity of immutability.

### Base terminology

+ **org.immutables**
  - Name following reverse-domain-name java package naming convention: _org.immutables_ is:
      - In most broadest sense it is open source software project on [Github immutables/org.immutables](https://github.com/immutables/org.immutables),
        whose documentation you are currently reading.
      - The annotation processor and corresponding libraries produced by this project.

+ **Abstract value class**
  - Manually written class that defines value class and is annotated
    with `org.immutable.annotation.GenerateImmutable` annotation. May contain **attributes** and other metadata,
    as well as regular java methods and fields if needed. It is strongly recommended to not introduce
    visible mutable state in abstract value class. Abstract value classes are used as the source
    model for generated code.

+ **Attribute**
  - In context of **abstract value class**, attribute is zero argument, non-`void` java method that declares
    accessor for the auto-generated fields. Attribute value cannot be changed after object is created.
    It is intentionally named "attribute" to distinguish from "field" and JavaBean "property" and to draw similarity
    with annotation type attributes. To make code less cluttered, no annotation required on abstract accessor method to
    became attribute, however some attributes, such as attributes with default values, will non-`abstract` method and
    thus will require annotation to distinguish from regular method.

+ **Immutable implementation class**
  - Generated `public final class` that extends manually-written **Abstract value class**
    and implements all declared accessor methods as well as supporting fields, methods, constructors and builder class.
    `Object`'s methods `equals`, `hashCode` and `toString()` are overriden an fully dependent on attribute values
    rather that object identity. 
    Immutable implementation class is primary, but not the only source code artifact
    generated by _org.immutables_ annotation processor.

Features
--------

-----
### Attributes
Immutable implementation class implements abstract attribute accessors for scalar primitive and object reference types.
Any attribute that declared as `abstract` methods

-----
<a name="builder"></a>
### Builder
By default, builders are generated for each immutable implementation class.
Builders enable expressive construction of object using named attribute initializers,
and generally builders compensates lack of named and optional constructor arguments in Java language.

+ To create builder invoke static `builder()` method on generated immutable implementation class
+ Invoke attribute initializer methods to set attributes
+ Call `build()` methods to construct immutable instance after attributes are initialized.
  Build method will fail if any mandatory attribute is omitted.

```java
// builder methods illustrated
ImmutableObject.builder()
    .attribute1(1442)
    .anotherAttribute(true)
    .addListAttribute("a")
    .addListAttribute("b")
    .addAllSetAttribute(Arrays.asList("1", "2"))
    .optionalAttribute("value")
    .putMapAttribute(key, value)
    .build();
```

If builder became redundant in presence of [constructor](#constructor), you can disable generation of builder
using `@GenerateImmutable(builder = false)` annotation parameter.

In advanced usage of builders you will want to pass builders that builds different types of objects but conform to the
same interface, akin to original [Builder pattern](http://en.wikipedia.org/wiki/Builder_pattern).
It is archivable by declaring static nested class named "Builder",
which will be extended by generated builder.

```java
interface Weapon {
  // we are peaceful: our weapon won't get any fire methods )
}

interface WeaponBuilder {
  // Generated builders will implement this method
  // It is compatible with signature of generated builder methods where
  // return type is narrowed to Railgun or RocketLauncher
  Weapon build();
}

@GenerateImmutable
public abstract class Railgun implements Weapon {
  public abstract class Builder implements WeaponBuilder {}
}

@GenerateImmutable
public abstract class RocketLauncher implements Weapon {
  public abstract class Builder implements WeaponBuilder {}
}

class Builders {
  void buildAndThrowAwayWeapon(WeaponBuilder builder) {
    Weapon throwawayWeapon = builder.build();
  }
  
  void exercise() {
    buildAndThrowAwayWeapon(ImmutableRailgun.builder());
    buildAndThrowAwayWeapon(ImmutableRocketLauncher.builder());
  }
}
```

Explicitly declared "Builder" could specify all needed `extends` of `implements` declarations
as well as it could have convenience methods that will show up on immutable object builder.
However special care should be taken in order to maintain structural compatibility of
declared builder supertype and generated builders, otherwise compile error will occur in generated code.

----
<a name="constructor"></a>
### Constructor
As an alternative to builder, it is possible to provide concise "constructor" factory method.
Constructor will be available as `static` method named `of` on immutable implementation class.

In order to generate constructor method, certain attributes should be annotated
with `org.immutables.annotation.GenerateConstructorParameter` annotation.

```java
@GenerateImmutable
public abstract class HostWithPort {
  @GenerateConstructorParameter(order = 0)
  public abstract String hostname();
  @GenerateConstructorParameter(order = 1)
  public abstract int port();
}
...
HostWithPort hostWithPort = ImmutableHostWithPort.of("localhost", 8081);

boolean willBeTrue = hostWithPort.equals(
    ImmutableHostWithPort.builder()
        .hostname("localhost")
        .port(8081)
        .build());
```

If there's more that one constructor parameter it is advised to put `order` annotation attribute to make constructor
parameter order deterministic across java compilers that may not honor source order.
See [JSR 269: Clarify ordering requirements...](http://bugs.sun.com/view_bug.do?bug_id=6884227). 

**Possible problems**

+ If not all mandatory attributes are marked as `@GenerateConstructorParameter`
  - Compilation error in the generated code: not all final fields were initialized in constructor
+ If `order` attribute on `@GenerateConstructorParameter` is omitted, then ECJ could generate code
  that differs from javac output, see [bug 300408](https://bugs.eclipse.org/bugs/show_bug.cgi?id=300408). 
  - could result in compile error in code that calls generated factory method due to misplaced parameters.

----
<a name="collection"></a>
### Collection and Map attributes

Following collection types enjoy built-in support for convenient usage:

+ `java.util.List`

+ `java.util.Set`

+ `java.util.Map`

Collection attributes are backed by Guava immutable collections,
moreover, `java.util.Set` and `java.util.Map` with `enum` keys
are backed by efficient `EnumSet` and `EnumMap` implementations.

Any container attribute is non mandatory to specify using builder.
This behavior could be altered in some ways, for example, see [Precondition check method](#check-method)

[Builders](#builder) have special methods to initialize collection attributes:

+ for set or list attribute named `Foo` where elements are of type `T`
  - `addFoo(T)`
  - `addAllFoo(Iterable<? extends T>)`
  - `clearFoo()`
  
+ for map attribute named `Bar` where keys are of type `K` and values of type `V`
  - `putBar(K, V)`
  - `putBar(Map.Entry<? extends K, ? extends V>)`
  - `putAllBar(Map<? extends K, ? extends K>)`
  - `clearBar()`

----
### Optional attributes

Attributes declared with return type of `com.google.common.base.Optional<T>`
defines [logically optional](https://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained#Optional)
attribute of type `T`. 

Optional value could be omitted when building object, and will default to `Optional.absent()`.
Generated builders have special initializer for optional attributes:

+ for optional attribute named `opt` where elements are of type `T`
  - `opt(T)` sets present value for T
  - `opt(Optional<T>)` specifies present or absent

-----
<a name="default-attribute"></a>
### Default attributes

We could allow attribute to have some default value if it was omitted with [builder](#builder).
To declare default attribute, create non-abstract attribute initializer method and annotate it with
`org.immutables.annotation.GenerateDefault`. If value was omitted during construction, this initializer method will be called to
retrieve default value of the attribute and store. After that accessor method will return stored value.

```java
@GenerateImmutable
public abstract class PlayerInfo {

  @GenerateConstructorParameter
  public abstract long id();
  
  @GenerateDefault
  public String name() {
    return "Anonymous_" + id(); 
  }
  
  @GenerateDefault
  public int gamesPlayed() {
    return 0; 
  }
}
...

PlayerInfo veteran = ImmutablePlayerInfo.builder()
    .id(1)
    .name("Fiddler")
    .gamesPlayed(99)
    .build();

PlayerInfo anonymous44 = ImmutablePlayerInfo.of(44);

String name = anonymous44.name(); // Anonymous_44
``` 

Default attribute method's body should not refer to any other derived or default attribute.
Otherwise construction will be broken due to unspecified initialization order.
It's only guaranteed that all attributes with abstract accessors will be initialized before
default and derived attributes, and therefore could be safely referred in initializers. 

-----
<a name="derived-attribute"></a>
### Derived attributes
Derived attributes may be read from immutable instance, but it could not be set. It's value is usually derived
from other attributes.

To declare derived attribute, create non-abstract attribute initializer method and annotate it with
`org.immutables.annotation.GenerateDerived`. Much like [default attributes](#default-attribute),
body of the method should compute and return value of an attribute. Derived attributes acts much like
regular methods that simply compute and return some value, but with single important difference:
value of derived attribute computed once and stored to a field (in the end of object construction).

```java
@GenerateImmutable
public abstract class Order {

  public abstract List<Item> items();

  @GenerateDerived
  public int totalCount() {
    int count = 0;

    for (Item i : items())
      count += i.count();
      
    return count;
  }
}

Order order = ImmutableOrder.builder()
    .addItems(Item.of("item1", 11))
    .addItems(Item.of("item2", 22))
    .build();

// total count will be already computed
int totalCount33 = order.totalCount();
```

Derived attribute method's body should not refer to any other derived or default attribute.
Otherwise construction will be broken due to unspecified initialization order.
It's only guaranteed that all attributes with abstract accessors will be initialized before
default and derived attributes, and therefore could be safely referred in initializers. 

-----
<a name="check-method"></a>
### Precondition check method
One of the core advantages of immutable objects is the fact that an immutable object will be constructed with
proper attribute values in _consistent state_ and _never changes_ afterwards.
So often arises a need to check attribute values or combination of attribute values (cross validation)
for correctness.

Given there's no hand-written constructor in a immutable implementation class,
you can write `protected` method annotated with `@GenerateCheck` and throw runtime exceptions if precondition failed.

```java
@GenerateImmutable
public abstract class NumberContainer {
  public abstract List<Number> nonEmptyNumbers();
  
  @GenerateCheck
  protected void check() {
    Preconditions.checkState(!nonEmptyNumbers().isEmpty(),
        "'nonEmptyNumbers' should have at least one number");
  }
}
...
// will throw IllegalStateException("'nonEmptyNumbers' should have at least one number")
ImmutableNumberContainer.builder().build();
```

However, one should notice how this differs from other kinds of object state validation
where object may be constructed with some values and later validated for correctness
regarding business rules in some context. Precondition checking should not be used to validate against such rules,
but to preserve consistency and guarantee that instances will be usable.

Precondition check methods runs when immutable object _instantiated and all attributes are initialized_,
but _before returned to caller_. Any instance that failed precondition
check is unreachable to caller due to runtime exception.

**Possible problems**

+ Wrong signature for the check method
  - Compilation error with fine diagnostic message explaining correct signature

-----
### Singleton instances

It is easy to create "empty" or "default" instances that will be singletons.
Use `@GenerateImmutable(singleton = true)` annotation parameter to generate singleton instances, use concise `of()`
factory method to obtain singleton instance.

```java
@GenerateImmutable(singleton = true)
public abstract class DataContainer {
  public abstract Set<String> dataChunks();
}

...
boolean willBeTrue =
    ImmuableDataContainer.of() == ImmuableDataContainer.of();
    
boolean willBeFalse =
    ImmuableDataContainer.of().equals(ImmuableDataContainer.builder().build());

```

Abstract value class should not have any mandatory attributes, otherwise generation of singletons will not be possible.
You can make attributes non-mandatory by using [default attributes](#default-attribute).

As it stands, empty singleton instances could be combined with builders and constructors as long
as all attributes are non-mandatory. But if there should be forced
one and _only one_ instance of particular immutable type, following recipe will do:

+ Use `singleton = true` and `builder = false` with `@GenerateImmutable` annotation
+ Do not use any `@GenerateConstructorParameter` on attributes 

```java
@GenerateImmutable(singleton = true, builder = false)
public abstract class Singleton {
  // Limit constructor accessibility to a package
  Singleton() {}
}

...
Singleton singleInstance = ImmutableSingleton.of();
```

**Possible problems**

+ If abstract value class contains mandatory attributes
  - Compilation error for the generated code: all final fields should be initialized in constructor

-----
<a name="interning"></a>
### Interning
There are cases when number of values of certain type expected to be finite and
measurable performance improvements may be gained by interning those instances.   

If all you need is to _strongly_ intern value objects, _org.immutables_ will handle it for you.
Just use `@GenerateImmutable(interned = true)` annotation parameter to enable strong interning:

+ Any object returned by builder or constructor will be interned and "canonical" instance returned 
+ `equals` will be short-circuited to object reference equality.

Support for object interning is specific to strong interning.
Soft and Weak interning as well as any forms of partial interning were out of scope and left
to be implemented externally.

-----
<a name="prehashed"></a>
### Precomputed hashCode
If immutable object have a lot of attributes or attributes may contain reasonably large
object graphs, it may be less efficient to work with immutable objects when generated `hashCode` methods
is queried again and again in sets or maps based on hashtables.
In such case, hash code may be precomputed on construction and stored for fast retrieval.
Just use `@GenerateImmutable(prehashed = true)` annotation parameter to enable hash computing in advance.

-----
### Customize `toString`, `hashCode` and `equals`
It's quite easy to customize generated `toString`, `hashCode` and `equals` methods,
in fact it is as easy as just implement them yourself in abstract value class.
_org.immutables_ processor will not override such manual methods with generated ones. 

```java
@GenerateImmutable
public abstract OmniValue {

  public boolean equals(Object object) {
    return object instanceof OmniValue;
  }
  
  public int hashCode() {
    return 1;
  }

  public String toString() {
    return "OmniValue{*}";
  }
}

boolean willBeTrue =
    ImmutableOmniValue.builder().build()
        .equals(new OmniValue() {});
```

Pleasant thing to note is that such manually written `equals` and `hashCode` methods will work
fine with [instance interning](#interning) and [precomputed hashCode](#prehashed) features!

Be careful to match signatures of `Object` methods to correctly override them, but not to accidentally overload.

It is deemed to be redundantly to note, but you should implement `equals`
and `hashCode` correctly and only if you a know what you are doing.

-----
### Modifiable companion
See [@GenerateModifiable](https://github.com/immutables/org.immutables/blob/master/annotation/src/org/immutables/annotation/GenerateModifiable.java)

-----
Patterns
-----
This section contains common patterns and recipes using _org.immutables_
that are useful but not actually features by themselves.

### Expressive factory methods

-----
### Smart data

-----
### Protected attributes

-----
### Null-Object pattern in attribute values

-----
Limitations
-----
Some features are not implemented due to lack of time or interest,
while other features were consciously rejected.
Some features were implemented with a basic, unoptimized solution.
Here mentioned several limitation and some not implemented features.

- Only top level abstract classes supported as abstract value classes.

- Generated classes are public. As of now, it is not possible to refine visibility of generated classes.

- Default and derived attributes cannot reliably refer to any other default or derived attribute.

- Lazily computed attributes were not implemented yet: lack of interest and some complexity with atomic initialization of lazy value

- Abstract value class could not be parameterized with type variables,
  however it could extends or implement parameterized type, given actual types supplied.
