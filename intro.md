---
title: 'Intro'
layout: page
---


To get benefits of immutability in Java we created the annotation processor
to easily create simple and consistent value objects. You can think of it as
[Guava's Immutable Collections](https://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained)
but for regular objects.

The core of _Immutables_ is modeling. Fine modelling is at heart of creating good application,
services and good design in general. We feel proud to fill a gap in modelling in the Java language,
where usage of JavaBeans just insufficient.

* Immutable object constructed once, in consistent state and can be safely shared
  - Will fail if mandatory attribute is missing
  - No sneaky modification when passed to other code
* Immutable objects are naturally thread-safe and can be safely shared among threads
  - No excessive copying
  - No excessive synchronization
* Object definitions are pleasant to write and read
  - No boilerplate setter and getters
  - No ugly IDE-generated `hashCode`, `equals` and `toString` methods that are stored in source control.

You create an **abstract value type** then add annotation to generate **immutable implementation class**.
See [sample generated code](http://immutables.github.com/generated.html) for an example of what kind of code is being generated by processor.

_Immutables_ have been in development for over two years counting from it's earliest prototypes.
Core of the toolkit is being successfully used in production:
it was used for development airline inventory system components, travel deal price aggregators and other application
that take advantages of efficient in-memory storage and concurrent computations on JVM.

We don't tend to overestimate the significance of this particular toolkit, but what it does is a strong
support for the disciplined reduction of system complexity, put it simple more immutability — less things to worry about.
[Guava](https://code.google.com/p/guava-libraries) is used as utility library for generated classes, but in addition we employ effective API style popularized by "Effective Java, Second Edition" book and Guava Library.

It may seem that usage _Immutables_ may result in some sort of [anemic domain model](http://www.martinfowler.com/bliki/AnemicDomainModel.html),
however, this impression is false and we see great benefits of proper domain modelling. But we need solid building blocks — value objects,
a [smart data](http://immutables.github.com/immutable.html#smart-data) objects,
immutable values that have methods that compute other values and reduce complexity of services and entities.
Other aspect of modelling is representation of system state and domain entities as sequences of _events_ or _snapshots_.
The techniques like [event sourcing](http://martinfowler.com/eaaDev/EventSourcing.html) employs
benefits of immutable object graphs, allow sub-graphs to be shared between snapshots, transform system states,
or even reconstruct full system state at some point in time.
For that kind of systems we just made writing immutable objects a whole lot easier. 

Immutables annotation processor may be very useful if you wish to increase safety and consistency at application boundaries as well as in internal data structures,
create expressive data objects for your java API.

