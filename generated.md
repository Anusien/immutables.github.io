---
title: 'Generated code'
layout: page
---

Here's an illustration of what kind of code is being generated by annotation processor.
Let's start with minimalistic example. Generation of builder and copy methods is disabled,
there are no Guava or JSR-305 annotations libraries in classpath.

### Minimal tuple

```java
import org.immutables.value.Value;

@Value.Immutable(builder = false, copy = false)
interface Tuple {
  @Value.Parameter int getIndex();
  @Value.Parameter String getName();
}
```

Below is a source code of immutable implementation, generated during compilation.

```java
import java.util.Objects;
import javax.annotation.Generated;

/**
 * Immutable implementation of {@link Tuple}.
 * <p>
 * Use static factory method to create immutable instances:
 * {@code ImmutableTuple.of()}.
 */
@SuppressWarnings("all")
@Generated({"Immutables.generator", "Tuple"})
final class ImmutableTuple implements Tuple {
  private final int index;
  private final String name;

  private ImmutableTuple(int index, String name) {
    this.index = index;
    this.name = Objects.requireNonNull(name);
  }
  
  /**
   * {@inheritDoc}
   * @return value of {@code index} attribute
   */
  @Override
  public int getIndex() {
    return index;
  }
  
  /**
   * {@inheritDoc}
   * @return value of {@code name} attribute
   */
  @Override
  public String getName() {
    return name;
  }
  
  /**
   * This instance is equal to instances of {@code ImmutableTuple} with equal attribute values.
   * @return {@code true} if {@code this} is equal to {@code another} instance
   */
  @Override
  public boolean equals(Object another) {
    return this == another
        || (another instanceof ImmutableTuple && equalTo((ImmutableTuple) another));
  }
  
  private boolean equalTo(ImmutableTuple another) {
    return index == another.index
        && name.equals(another.name);
  }
  
  /**
   * Computes hash code from attributes: {@code index}, {@code name}.
   * @return hashCode value
   */
  @Override
  public int hashCode() {
    int h = 31;
    h = h * 17 + index;
    h = h * 17 + name.hashCode();
    return h;
  }
  
  /**
   * Prints immutable value {@code Tuple{...}} with attribute values,
   * excluding any non-generated and auxiliary attributes.
   * @return string representation of value
   */
  @Override
  public String toString() {
    return new StringBuilder("Tuple{")
        .append("index=").append(index)
        .append(", name=").append(name)
        .append('}').toString();
  }

  /**
   * Construct new immutable {@code Tuple} instance.
   * @param index value for {@code index}
   * @param name value for {@code name}
   * @return immutable Tuple instance
   */
  public static ImmutableTuple of(int index, String name) {
    return new ImmutableTuple(index, name);
  }
}

```

By default more stuff is generated, but as you could see above, those extras could be disabled
(see also [Style guide](/style.html) for examples of how to do this using meta-annotation).

### Typical value object
Here's more typical example of value object with builder, copy methods. Google Guava is present in classpath.

```java
import com.google.common.base.Optional;
import java.util.List;
import org.immutables.value.Value;

@Value.Immutable
interface ValueObject {
  long id();
  String name();
  List<Number> numbers();
  Optional<String> comment();
  long[] data();
}
```

You will probably agree that code below should not be written by hand:

```java
import com.google.common.base.Objects;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.primitives.Longs;
import java.util.Arrays;
import java.util.Collection;
import javax.annotation.Generated;
import javax.annotation.Nullable;
import javax.annotation.ParametersAreNonnullByDefault;
import javax.annotation.concurrent.Immutable;
import javax.annotation.concurrent.NotThreadSafe;

/**
 * Immutable implementation of {@link ValueObject}.
 * <p>
 * Use builder to create immutable instances:
 * {@code ImmutableValueObject.builder()}.
 */
@SuppressWarnings("all")
@ParametersAreNonnullByDefault
@Generated({"Immutables.generator", "ValueObject"})
@Immutable
final class ImmutableValueObject implements ValueObject {
  private final long id;
  private final String name;
  private final ImmutableList<Number> numbers;
  private final Optional<String> comment;
  private final long[] data;

  private ImmutableValueObject(ImmutableValueObject.Builder builder) {
    this.id = builder.id;
    this.name = builder.name;
    this.numbers = builder.numbersBuilder.build();
    this.comment = builder.comment;
    this.data = builder.data;
  }

  private ImmutableValueObject(
      ImmutableValueObject original,
      long id,
      String name,
      ImmutableList<Number> numbers,
      Optional<String> comment,
      long[] data) {
    this.id = id;
    this.name = name;
    this.numbers = numbers;
    this.comment = comment;
    this.data = data;
  }
  
  /**
   * {@inheritDoc}
   * @return value of {@code id} attribute
   */
  @Override
  public long id() {
    return id;
  }
  
  /**
   * {@inheritDoc}
   * @return value of {@code name} attribute
   */
  @Override
  public String name() {
    return name;
  }
  
  /**
   * {@inheritDoc}
   * @return value of {@code numbers} attribute
   */
  @Override
  public ImmutableList<Number> numbers() {
    return numbers;
  }
  
  /**
   * {@inheritDoc}
   * @return value of {@code comment} attribute
   */
  @Override
  public Optional<String> comment() {
    return comment;
  }
  
  /**
   * {@inheritDoc}
   * @return cloned {@code data} array
   */
  @Override
  public long[] data() {
    return data.clone();
  }
  
  /**
   * Copy current immutable object by setting value for {@link ValueObject#id() id}.
   * Value equality check is used to prevent copying of the same value by returning {@code this}.
   * @param value new value for id
   * @return modified copy of the {@code this} object
   */
  public final ImmutableValueObject withId(long value) {
    if (this.id == value) {
      return this;
    }
    long newValue = value;
    return new ImmutableValueObject(this, newValue, this.name, this.numbers, this.comment, this.data);
  }
  
  /**
   * Copy current immutable object by setting value for {@link ValueObject#name() name}.
   * Shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
   * @param value new value for name
   * @return modified copy of the {@code this} object
   */
  public final ImmutableValueObject withName(String value) {
    if (this.name == value) {
      return this;
    }
    String newValue = Preconditions.checkNotNull(value);
    return new ImmutableValueObject(this, this.id, newValue, this.numbers, this.comment, this.data);
  }
  
  /**
   * Copy current immutable object with elements that replace content of {@link ValueObject#numbers() numbers}.
   * @param elements elements to set
   * @return modified copy of {@code this} object
   */
  public final ImmutableValueObject withNumbers(Number... elements) {
    ImmutableList<Number> newValue = ImmutableList.copyOf(elements);
    return new ImmutableValueObject(this, this.id, this.name, newValue, this.comment, this.data);
  }
  
  /**
   * Copy current immutable object with elements that replace content of {@link ValueObject#numbers() numbers}.
   * Shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
   * @param elements iterable of numbers elements to set
   * @return modified copy of {@code this} object
   */
  public final ImmutableValueObject withNumbers(Iterable<? extends Number> elements) {
    if (this.numbers == elements) {
      return this;
    }
    ImmutableList<Number> newValue = ImmutableList.copyOf(elements);
    return new ImmutableValueObject(this, this.id, this.name, newValue, this.comment, this.data);
  }
  
  /**
   * Copy current immutable object by setting present value for optional {@link ValueObject#comment() comment}.
   * @param value value for comment
   * @return modified copy of {@code this} object
   */
  public final ImmutableValueObject withComment(String value) {
    Optional<String> newValue = Optional.of(value);
    return new ImmutableValueObject(this, this.id, this.name, this.numbers, newValue, this.data);
  }
  
  /**
   * Copy current immutable object by setting optional value for {@link ValueObject#comment() comment}.
   * Shallow reference equality check on optional value is used to prevent copying of the same value by returning {@code this}.
   * @param optional value for comment
   * @return modified copy of {@code this} object
   */
  public final ImmutableValueObject withComment(Optional<String> optional) {
    if (this.comment == optional) {
      return this;
    }
    Optional<String> newValue = Preconditions.checkNotNull(optional);
    return new ImmutableValueObject(this, this.id, this.name, this.numbers, newValue, this.data);
  }
  
  /**
   * Copy current immutable object with elements that replace content of {@link ValueObject#data() data}.
   * Array is cloned before saved as the attribute value.
   * @param elements elements for data, not null
   * @return modified copy of {@code this} object
   */
  public final ImmutableValueObject withData(long... elements) {
    long[] newValue = elements.clone();
    return new ImmutableValueObject(this, this.id, this.name, this.numbers, this.comment, newValue);
  }
  
  /**
   * This instance is equal to instances of {@code ImmutableValueObject} with equal attribute values.
   * @return {@code true} if {@code this} is equal to {@code another} instance
   */
  @Override
  public boolean equals(@Nullable Object another) {
    return this == another
        || (another instanceof ImmutableValueObject && equalTo((ImmutableValueObject) another));
  }
  
  private boolean equalTo(ImmutableValueObject another) {
    return id == another.id
        && name.equals(another.name)
        && numbers.equals(another.numbers)
        && comment.equals(another.comment)
        && Arrays.equals(data, another.data);
  }
  
  /**
   * Computes hash code from attributes: {@code id}, {@code name}, {@code numbers}, {@code comment}, {@code data}.
   * @return hashCode value
   */
  @Override
  public int hashCode() {
    int h = 31;
    h = h * 17 + Longs.hashCode(id);
    h = h * 17 + name.hashCode();
    h = h * 17 + numbers.hashCode();
    h = h * 17 + comment.hashCode();
    h = h * 17 + Arrays.hashCode(data);
    return h;
  }
  
  /**
   * Prints immutable value {@code ValueObject{...}} with attribute values,
   * excluding any non-generated and auxiliary attributes.
   * @return string representation of value
   */
  @Override
  public String toString() {
    return Objects.toStringHelper("ValueObject")
        .add("id", id)
        .add("name", name)
        .add("numbers", numbers)
        .add("comment", comment)
        .add("data", Arrays.toString(data))
        .toString();
  }
  
  /**
   * Creates immutable copy of {@link ValueObject}.
   * Uses accessors to get values to initialize immutable instance.
   * If an instance is already immutable, it is returned as is.
   */
  static ImmutableValueObject copyOf(ValueObject instance) {
    if (instance instanceof ImmutableValueObject) {
      return (ImmutableValueObject) instance;
    }
    return ImmutableValueObject.builder()
        .from(instance)
        .build();
  }

  /**
   * Creates builder for {@link ImmutableValueObject}.
   * @return new ImmutableValueObject builder
   */
  static ImmutableValueObject.Builder builder() {
    return new ImmutableValueObject.Builder();
  }
  
  /**
   * Builds instances of {@link ImmutableValueObject}.
   * Initialized attributes and then invoke {@link #build()} method to create
   * immutable instance.
   * <p><em>Builder is not thread safe and generally should not be stored in field or collection,
   * but used immediately to create instances.</em>
   */
  @NotThreadSafe
  static final class Builder {
    private static final long INITIALIZED_BITSET_ALL = 0x7;
    private static final long INITIALIZED_BIT_ID = 0x1L;
    private static final long INITIALIZED_BIT_NAME = 0x2L;
    private static final long INITIALIZED_BIT_DATA = 0x4L;
    private long initializedBitset;
  
    private long id;
    private @Nullable String name;
    private ImmutableList.Builder<Number> numbersBuilder = ImmutableList.builder();
    private Optional<String> comment = Optional.absent();
    private @Nullable long[] data;
    private Builder() {}
  
    /**
     * Adjust builder with values from provided {@link ValueObject} instance.
     * Regular attribute values will be overridden, i.e. replaced with ones of an instance.
     * Instance's absent optional values will not be copied (will not override current).
     * Collection elements and entries will be added, not replaced.
     * @param instance instance to copy values from
     * @return {@code this} builder for chained invocation
     */
    public final Builder from(ValueObject instance) {
      Preconditions.checkNotNull(instance);
      id(instance.id());
      name(instance.name());
      addAllNumbers(instance.numbers());
      Optional<String> commentOptional = instance.comment();
      if (commentOptional.isPresent()) {
        comment(commentOptional);
      }
      data(instance.data());
      return this;
    }
  
    /**
     * Initializes value for {@link ValueObject#id() id}.
     * @param id value for id
     * @return {@code this} builder for chained invocation
     */
    public final Builder id(long id) {
      this.id = id;
      initializedBitset |= INITIALIZED_BIT_ID;
      return this;
    }
  
    /**
     * Initializes value for {@link ValueObject#name() name}.
     * @param name value for name
     * @return {@code this} builder for chained invocation
     */
    public final Builder name(String name) {
      this.name = Preconditions.checkNotNull(name);
      initializedBitset |= INITIALIZED_BIT_NAME;
      return this;
    }
  
    /**
     * Adds one element to {@link ValueObject#numbers() numbers} list.
     * @param element numbers element
     * @return {@code this} builder for chained invocation
     */
    public final Builder addNumbers(Number element) {
      numbersBuilder.add(element);
      return this;
    }
  
    /**
     * Adds elements to {@link ValueObject#numbers() numbers} list.
     * @param elements array of numbers elements
     * @return {@code this} builder for chained invocation
     */
    public final Builder addNumbers(Number... elements) {
      numbersBuilder.add(elements);
      return this;
    }
  
    /**
     * Sets or replaces all elements for {@link ValueObject#numbers() numbers} list.
     * @param elements iterable of numbers elements
     * @return {@code this} builder for chained invocation
     */
    public final Builder numbers(Iterable<? extends Number> elements) {
      numbersBuilder = ImmutableList.builder();
      return addAllNumbers(elements);
    }
  
    /**
     * Adds elements to {@link ValueObject#numbers() numbers} list.
     * @param elements iterable of numbers elements
     * @return {@code this} builder for chained invocation
     */
    public final Builder addAllNumbers(Iterable<? extends Number> elements) {
      numbersBuilder.addAll(elements);
      return this;
    }
  
    /**
     * Initializes present value for optional {@link ValueObject#comment() comment}.
     * @param comment value for comment
     * @return {@code this} builder for chained invocation
     */
    public final Builder comment(String comment) {
      this.comment = Optional.of(comment);
      return this;
    }
  
    /**
     * Initializes optional value for {@link ValueObject#comment() comment}.
     * @param comment value for comment
     * @return {@code this} builder for chained invocation
     */
    public final Builder comment(Optional<String> comment) {
      this.comment = Preconditions.checkNotNull(comment);
      return this;
    }
  
    /**
     * Initializes value for {@link ValueObject#data() data}.
     * @param elements elements for data
     * @return {@code this} builder for chained invocation
     */
    public final Builder data(long... elements) {
      this.data = elements.clone();
      initializedBitset |= INITIALIZED_BIT_DATA;
      return this;
    }
  
    /**
     * Builds new {@link ImmutableValueObject}.
     * @return immutable instance of ValueObject
     */
    public ImmutableValueObject build() {
      checkRequiredAttributes();
      return new ImmutableValueObject(this);
    }
  
    private boolean idIsSet() {
      return (initializedBitset & INITIALIZED_BIT_ID) != 0;
    }
  
    private boolean nameIsSet() {
      return (initializedBitset & INITIALIZED_BIT_NAME) != 0;
    }
  
    private boolean dataIsSet() {
      return (initializedBitset & INITIALIZED_BIT_DATA) != 0;
    }
  
    private void checkRequiredAttributes() {
      if (initializedBitset != INITIALIZED_BITSET_ALL) {
        throw new IllegalStateException(formatRequiredAttributesMessage());
      }
    }
  
    private String formatRequiredAttributesMessage() {
      Collection<String> attributes = Lists.newArrayList();
      if (!idIsSet()) {
        attributes.add("id");
      }
      if (!nameIsSet()) {
        attributes.add("name");
      }
      if (!dataIsSet()) {
        attributes.add("data");
      }
      return "Cannot build ValueObject, some of required attributes are not set " + attributes;
    }
  }
}
```
