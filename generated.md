---
title: 'Sample generated code'
layout: page
---

Here's an illustration of what kind of code is being generated by annotation processor.

### ValueObject

```java
package info.sample;

import com.google.common.base.Optional;
import java.util.List;
import org.immutables.annotation.GenerateImmutable;

@GenerateImmutable
public abstract class ValueObject {
  public abstract String name();
  public abstract long value();
  public abstract List<Integer> numbers();
  public abstract Optional<String> optional();
}
```

### ImmutableValueObject

```java
package info.sample;

import com.google.common.base.Objects;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.primitives.Longs;
import java.util.List;
import javax.annotation.Generated;
import javax.annotation.Nullable;
import javax.annotation.ParametersAreNonnullByDefault;
import javax.annotation.concurrent.Immutable;
import javax.annotation.concurrent.NotThreadSafe;

/**
 * Immutable implementation of {@link ValueObject}.
 * <p>
 * Use static static factory methods to create instances: {@code of()} or
 * {@code builder()}.
 */
@SuppressWarnings("unused")
@ParametersAreNonnullByDefault
@Generated({"immutable.tjs", "ValueObject"})
@Immutable
public final class ImmutableValueObject
    extends ValueObject {

  private static ImmutableValueObject checkPreconditions(ImmutableValueObject instance) {
    return instance;
  }

  private final String name;
  private final long value;
  private final List<Integer> numbers;
  private final Optional<String> optional;

  private ImmutableValueObject(Builder builder) {
    this.name = builder.name;
    this.value = builder.value;
    this.numbers = builder.numbersBuilder.build();
    this.optional = builder.optional;
  }

  @Override
  public String name() {
    return name;
  }

  @Override
  public long value() {
    return value;
  }

  @Override
  public List<Integer> numbers() {
    return numbers;
  }

  @Override
  public Optional<String> optional() {
    return optional;
  }

  @Override
  public boolean equals(Object another) {
    return this == another
        || (another instanceof ImmutableValueObject && equalTo((ImmutableValueObject) another));
  }

  private boolean equalTo(ImmutableValueObject another) {
    return true
          && name.equals(another.name)
          && value == another.value
          && numbers.equals(another.numbers)
          && optional.equals(another.optional);
  }

  private int computeHashCode() {
    int h = 31;
    h = h * 17 + name.hashCode();
    h = h * 17 + Longs.hashCode(value);
    h = h * 17 + numbers.hashCode();
    h = h * 17 + optional.hashCode();
    return h;
  }

  @Override
  public int hashCode() {
    return computeHashCode();
  }

  @Override
  public String toString() {
    return Objects.toStringHelper("ValueObject")
        .add("name", name)
        .add("value", value)
        .add("numbers", numbers)
        .add("optional", optional)
        .toString();
  }

  /**
   * Creates builder for {@link ValueObject}.
   * @return new ValueObject builder
   */
  public static Builder builder() {
    return new Builder();
  }

  /**
   * Builds instances of {@link ValueObject}.
   * Builder is not thread safe and generally should not be stored in fields and collections,
   * but used immediately to create instances.
   */
  @NotThreadSafe
  public static final class Builder {
    private static final String REQUIRED_ATTRIBUTE =
        "Cannot build ValueObject: required attribute '%s' is not set";

    @Nullable
    private String name;
    private long value;
    private boolean valueIsSet;
    private ImmutableList.Builder<Integer> numbersBuilder =
        ImmutableList.builder();
    private Optional<String> optional = Optional.absent();

    private Builder() {
    }

    /**
     * Adjust builder with values from provided {@link ValueObject} instance.
     * Absent optional values will not be copied (will not override current).
     * Collection elements will be added, not replaced.
     * @param fromInstance instance to copy values from
     * @return {@code this} builder for chained invocation
     */
    public Builder copy(ValueObject fromInstance) {
      Preconditions.checkNotNull(fromInstance);
      name(fromInstance.name());
      value(fromInstance.value());
      addAllNumbers(fromInstance.numbers());
      Optional<String> optionalOptional = fromInstance.optional();
      if (optionalOptional.isPresent()) {
        optional = optionalOptional;
      }
      return this;
    }

    /**
     * Initializes value for {@link ValueObject#name()}.
     * @param name value for name, non-null
     * @return {@code this} builder for chained invocation
     */
    public Builder name(String name) {
      this.name = Preconditions.checkNotNull(name);
      return this;
    }

    /**
     * Initializes value for {@link ValueObject#value()}.
     * @param value value for value, non-null
     * @return {@code this} builder for chained invocation
     */
    public Builder value(long value) {
      this.value = value;
      valueIsSet = true;
      return this;
    }

    /**
     * Adds one element to {@link ValueObject#numbers()} list.
     * @param numbersElement single numbers element
     * @return {@code this} builder for chained invocation
     */
    public Builder addNumbers(int numbersElement) {
      numbersBuilder.add(numbersElement);
      return this;
    }

    /**
     * Adds elements to {@link ValueObject#numbers()} list.
     * @param numbersElements iterable of numbers elements
     * @return {@code this} builder for chained invocation
     */
    public Builder addAllNumbers(Iterable<? extends Integer> numbersElements) {
      numbersBuilder.addAll(numbersElements);
      return this;
    }

    /**
     * Clears all previously added elements for {@link ValueObject#numbers()} list.
     * @return {@code this} builder for chained invocation
     */
    public Builder clearNumbers() {
      numbersBuilder = ImmutableList.builder();
      return this;
    }

    /**
     * Initializes present value for optional {@link ValueObject#optional()}.
     * @param optional value for optional, nonull
     * @return {@code this} builder for chained invocation
     */
    public Builder optional(String optional) {
      this.optional(Optional.of(optional));
      return this;
    }

    /**
     * Initializes value for {@link ValueObject#optional()}.
     * @param optional value for optional, non-null
     * @return {@code this} builder for chained invocation
     */
    public Builder optional(Optional<String> optional) {
      this.optional = Preconditions.checkNotNull(optional);
      return this;
    }

    /**
     * Builds new {@link ValueObject}.
     * @return immutable instance of ValueObject
     */
    public ValueObject build() {
      Preconditions.checkState(name != null, REQUIRED_ATTRIBUTE, "name");
      Preconditions.checkState(valueIsSet, REQUIRED_ATTRIBUTE, "value");
      return checkPreconditions(new ImmutableValueObject(this));
    }
  }
}
```
