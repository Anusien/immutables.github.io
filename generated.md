---
title: 'Sample generated code'
layout: page
---

Here's an illustration of what kind of code is being generated by annotation processor.

### Value

```java
import com.google.common.base.Optional;
import java.util.List;
import org.immutables.value.Value;

@Value.Immutable
interface ValueObject {
  long id();
  String name();
  List<Number> numbers();
  Optional<String> comment();
  long[] data();
}
```

### ImmutableValue

```java
import com.google.common.base.MoreObjects;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.primitives.Longs;
import java.util.Arrays;
import javax.annotation.Generated;
import javax.annotation.Nullable;
import javax.annotation.ParametersAreNonnullByDefault;
import javax.annotation.concurrent.Immutable;
import javax.annotation.concurrent.NotThreadSafe;


/**
 * Immutable implementation of {@link ValueObject}.
 * <p>
 * Use static factory methods to create instances: {@code of()} or
 * {@code builder()}.
 */
@SuppressWarnings("all")
@ParametersAreNonnullByDefault
@Generated({"Immutables.generator", "ValueObject"})
@Immutable
final class ImmutableValueObject
    implements ValueObject {

  private static ImmutableValueObject checkPreconditions(ImmutableValueObject instance) {
    return instance;
  }

  /**
   * Creates immutable copy of ValueObject. Uses accessors to get values to initialize new immutable instance.
   * If instance is already immutable, it returns it unchanged.
   */
  public static ImmutableValueObject copyOf(ValueObject instance) {
    if (instance instanceof ImmutableValueObject) {
      return (ImmutableValueObject) instance;
    }
    Preconditions.checkNotNull(instance);
    return builder()
        .id(instance.id())
        .name(instance.name())
        .addAllNumbers(instance.numbers())
        .comment(instance.comment())
        .data(instance.data())
        .build();
  }

  /**
   * @deprecated Already an immutable object, no need to create immutable copy
   */
  @Deprecated
  public static ImmutableValueObject copyOf(ImmutableValueObject instance) {
    return Preconditions.checkNotNull(instance);
  }
  private final long id;
  private final String name;
  private final ImmutableList<Number> numbers;
  private final Optional<String> comment;
  private final long[] data;

  private ImmutableValueObject(Builder builder) {
    this.id = builder.id;
    this.name = builder.name;
    this.numbers = builder.numbersBuilder.build();
    this.comment = builder.comment;
    this.data = builder.data;
  }

  private ImmutableValueObject(
      ImmutableValueObject copiedInstance, 
      long id, 
      String name, 
      ImmutableList<Number> numbers, 
      Optional<String> comment, 
      long[] data) {
    this.id = id;
    this.name = name;
    this.numbers = numbers;
    this.comment = comment;
    this.data = data;
  }

  /**
   * Copy current immutable object by setting value for {@link ValueObject#id()}.
   * Value equality check is used to prevent copying of the same value by returning {@code this}.
   * @param value value for id, non-null
   * @return modified copy of the {@code this} object
   */
  public final ImmutableValueObject withId(long value) {
    if (this.id == value) {
      return this;
    }
    long newValue = value;
    return checkPreconditions(new ImmutableValueObject(
        this, 
        newValue, 
        this.name, 
        this.numbers, 
        this.comment, 
        this.data));
  }

  /**
   * Copy current immutable object by setting value for {@link ValueObject#name()}.
   * Shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
   * @param value value for name, non-null
   * @return modified copy of the {@code this} object
   */
  public final ImmutableValueObject withName(String value) {
    if (this.name == value) {
      return this;
    }
    String newValue = Preconditions.checkNotNull(value);
    return checkPreconditions(new ImmutableValueObject(
        this, 
        this.id, 
        newValue, 
        this.numbers, 
        this.comment, 
        this.data));
  }

  /**
   * Copy current immutable object with elements that replace content of {@link ValueObject#numbers()}.
   * @param elements elements to set
   * @return modified copy of {@code this} object
   */
  public final ImmutableValueObject withNumbers(Number... elements) {
    ImmutableList<Number> newValue = ImmutableList.copyOf(  Arrays.asList(elements));
    return checkPreconditions(new ImmutableValueObject(
        this, 
        this.id, 
        this.name, 
        newValue, 
        this.comment, 
        this.data));
  }

  /**
   * Copy current immutable object with elements that replace content of {@link ValueObject#numbers()}.
   * Shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
   * @param elements iterable of numbers elements to set
   * @return modified copy of {@code this} object
   */
  public final ImmutableValueObject withNumbers(Iterable<? extends Number> elements) {
    if (this.numbers == elements) {
      return this;
    }
    ImmutableList<Number> newValue = ImmutableList.copyOf(elements);
    return checkPreconditions(new ImmutableValueObject(
        this, 
        this.id, 
        this.name, 
        newValue, 
        this.comment, 
        this.data));
  }

  /**
   * Copy current immutable object by setting present value for optional {@link ValueObject#comment()}.
   * @param value value for comment, non-null
   * @return modified copy of {@code this} object
   */
  public final ImmutableValueObject withComment(String value) {
    Optional<String> newValue = Optional.of(value);
    return checkPreconditions(new ImmutableValueObject(
        this, 
        this.id, 
        this.name, 
        this.numbers, 
        newValue, 
        this.data));
  }

  /**
   * Copy current immutable object by setting optional value for {@link ValueObject#comment()}.
   * Shallow reference equality check on optional value is used to prevent copying of the same value by returning {@code this}.
   * @param optional value for comment, non-null
   * @return modified copy of {@code this} object
   */
  public final ImmutableValueObject withComment(Optional<String> optional) {
    if (this.comment == optional) {
      return this;
    }
    Optional<String> newValue = Preconditions.checkNotNull(optional);
    return checkPreconditions(new ImmutableValueObject(
        this, 
        this.id, 
        this.name, 
        this.numbers, 
        newValue, 
        this.data));
  }

  /**
   * Copy current immutable object with elements that replace content of {@link ValueObject#data()}.
   * Array is cloned before saved as the attribute value.
   * @param elements iterable of data elements to set
   * @return modified copy of {@code this} object
   */
  public final ImmutableValueObject withData(long... elements) {
    long[] newValue = elements.clone();
    return checkPreconditions(new ImmutableValueObject(
        this, 
        this.id, 
        this.name, 
        this.numbers, 
        this.comment, 
        newValue));
  }

  @Override
  public long id() {
    return id;
  }

  @Override
  public String name() {
    return name;
  }

  @Override
  public ImmutableList<Number> numbers() {
    return numbers;
  }

  @Override
  public Optional<String> comment() {
    return comment;
  }

  @Override
  public long[] data() {
    return data.clone();
  }

  @Override
  public boolean equals(Object another) {
    return this == another
        || (another instanceof ImmutableValueObject && equalTo((ImmutableValueObject) another));
  }

  private boolean equalTo(ImmutableValueObject another) {
    return id == another.id
        && name.equals(another.name)
        && numbers.equals(another.numbers)
        && comment.equals(another.comment)
        && Arrays.equals(data, another.data);
  }

  private int computeHashCode() {
    int h = 31;
    h = h * 17 + Longs.hashCode(id);
    h = h * 17 + name.hashCode();
    h = h * 17 + numbers.hashCode();
    h = h * 17 + comment.hashCode();
    h = h * 17 + Arrays.hashCode(data);
    return h;
  }

  @Override
  public int hashCode() {
    return computeHashCode();
  }

  @Override
  public String toString() {
    return MoreObjects.toStringHelper("ValueObject")
        .add("id", id)
        .add("name", name)
        .add("numbers", numbers)
        .add("comment", comment.orNull())
        .add("data", Arrays.toString(data))
        .toString();
  }

  /**
   * Creates builder for {@link ValueObject}.
   * @return new ValueObject builder
   */
  public static Builder builder() {
    return new Builder();
  }

  /**
   * Builds instances of {@link ValueObject}.
   * Builder is not thread safe and generally should not be stored in fields and collections, 
   * but used immediately to create instances.
   */
  @NotThreadSafe
  static final class Builder {
    private Builder() {
    }

    private long initializedBitset0;
    private static final long INITIALIZED_BITSET_ALL_0 = 0x7;
    private static final long INITIALIZED_BIT_ID = 0x1L;

    private boolean idIsSet() {
      return (initializedBitset0 & INITIALIZED_BIT_ID) != 0;
    }
    private static final long INITIALIZED_BIT_NAME = 0x2L;

    private boolean nameIsSet() {
      return (initializedBitset0 & INITIALIZED_BIT_NAME) != 0;
    }
    private static final long INITIALIZED_BIT_DATA = 0x4L;

    private boolean dataIsSet() {
      return (initializedBitset0 & INITIALIZED_BIT_DATA) != 0;
    }
    private long id;
    @Nullable
    private String name;
    private ImmutableList.Builder<Number> numbersBuilder =
        ImmutableList.builder();
    private Optional<String> comment = Optional.absent();
    @Nullable
    private long[] data;

    @Override
    public String toString() {
      return MoreObjects.toStringHelper("ValueObject.Builder")
          .omitNullValues()
          .add("id", idIsSet() ? id : null)
          .add("name", name)
          .add("numbers", numbersBuilder.build())
          .add("comment", comment.orNull())
          .add("data", Arrays.toString(data))
          .toString();
    }

    /**
     * Initializes value for {@link ValueObject#id()}.
     * @param id value for id, non-null
     * @return {@code this} builder for chained invocation
     */
    public final Builder id(long id) {
      this.id = id;
      initializedBitset0 |= INITIALIZED_BIT_ID;
      return this;
    }

    /**
     * Initializes value for {@link ValueObject#name()}.
     * @param name value for name, non-null
     * @return {@code this} builder for chained invocation
     */
    public final Builder name(String name) {
      this.name = Preconditions.checkNotNull(name);
      initializedBitset0 |= INITIALIZED_BIT_NAME;
      return this;
    }

    /**
     * Adds one element to {@link ValueObject#numbers()} list.
     * @param element single numbers element
     * @return {@code this} builder for chained invocation
     */
    public final Builder addNumbers(Number element) {
      numbersBuilder.add(element);
      return this;
    }

    /**
     * Adds elements to {@link ValueObject#numbers()} list.
     * @param elements array of numbers elements
     * @return {@code this} builder for chained invocation
     */
    public final Builder addNumbers(Number... elements) {
      numbersBuilder.addAll(ImmutableList.copyOf(  Arrays.asList(elements)));
      return this;
    }
    /**
     * Adds elements to {@link ValueObject#numbers()} list.
     * @param elements iterable of numbers elements
     * @return {@code this} builder for chained invocation
     */
    public final Builder addAllNumbers(Iterable<? extends Number> elements) {
      numbersBuilder.addAll(elements);
      return this;
    }

    /**
     * Initializes present value for optional {@link ValueObject#comment()}.
     * @param comment value for comment, non-null
     * @return {@code this} builder for chained invocation
     */
    public final Builder comment(String comment) {
      this.comment(Optional.of(comment));
      return this;
    }

    /**
     * Initializes optional value for {@link ValueObject#comment()}.
     * @param comment value for comment, non-null
     * @return {@code this} builder for chained invocation
     */
    public final Builder comment(Optional<String> comment) {
      this.comment = Preconditions.checkNotNull(comment);
      return this;
    }

    /**
     * Initializes value for {@link ValueObject#data()}.
     * @param data value for data, non-null
     * @return {@code this} builder for chained invocation
     */
    public final Builder data(long... data) {
      this.data = data.clone();
      initializedBitset0 |= INITIALIZED_BIT_DATA;
      return this;
    }

    private void checkRequiredAttributes() {
      if (initializedBitset0 != INITIALIZED_BITSET_ALL_0) {
        throw new IllegalStateException(
            MoreObjects.toStringHelper("Cannot build ValueObject, some of required attributes are not set ")
                .omitNullValues()
                .addValue(!idIsSet() ? "id" : null)
                .addValue(!nameIsSet() ? "name" : null)
                .addValue(!dataIsSet() ? "data" : null)
                .toString());
      }
    }

    /**
     * Builds new {@link ValueObject}.
     * @return immutable instance of ValueObject
     */
    public ImmutableValueObject build() {
      checkRequiredAttributes();
      return checkPreconditions(new ImmutableValueObject(this));
    }
  }
}
```
