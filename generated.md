---
title: 'Sample generated code'
layout: page
---

Here's an illustration of what kind of code is being generated by annotation processor.

### ValueObject

```java
package info.sample;

import com.google.common.base.Optional;
import java.util.List;
import org.immutables.annotation.GenerateImmutable;

@GenerateImmutable
public abstract class ValueObject {
  public abstract long id();
  public abstract String name();
  public abstract List<Number> numbers();
  public abstract Optional<String> comment();
}
```

### ImmutableValueObject

```java
package info.sample;

import com.google.common.base.Objects;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.primitives.Longs;
import javax.annotation.Generated;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.annotation.ParametersAreNonnullByDefault;
import javax.annotation.concurrent.Immutable;
import javax.annotation.concurrent.NotThreadSafe;
import javax.annotation.meta.When;

/**
 * Immutable implementation of {@link ValueObject}.
 * <p>
 * Use static static factory methods to create instances: {@code of()} or
 * {@code builder()}.
 */
@SuppressWarnings("all")
@ParametersAreNonnullByDefault
@Generated({"immutable.tjs", "ValueObject"})
@Immutable
public final class ImmutableValueObject
    extends ValueObject {

  private static ImmutableValueObject checkPreconditions(ImmutableValueObject instance) {
    return instance;
  }

  private final long id;
  private final String name;
  private final ImmutableList<Number> numbers;
  private final Optional<String> comment;

  private ImmutableValueObject(Builder builder) {
    this.id = builder.id;
    this.name = builder.name;
    this.numbers = builder.numbersBuilder.build();
    this.comment = builder.comment;
  }

  private ImmutableValueObject(
      @Nonnull(when = When.NEVER)
      Void internalCopyContructorDisambiguation, 
      long id, String name, ImmutableList<Number> numbers, Optional<String> comment) {
    this.id = id;
    this.name = name;
    this.numbers = numbers;
    this.comment = comment;
  }
    
  /**
   * Copy current immutable object by setting value for {@link ValueObject#id()}.
   * @param id value for id, non-null
   * @return modified copy of the {@code this} object
   */
  public ImmutableValueObject withId(long id) {
    long idModifiedValue = id;
    return checkPreconditions(new ImmutableValueObject(
        (Void) null, 
        idModifiedValue, 
        this.name, 
        this.numbers, 
        this.comment));
  }
    
  /**
   * Copy current immutable object by setting value for {@link ValueObject#name()}.
   * @param name value for name, non-null
   * @return modified copy of the {@code this} object
   */
  public ImmutableValueObject withName(String name) {
    String nameModifiedValue = Preconditions.checkNotNull(name);
    return checkPreconditions(new ImmutableValueObject(
        (Void) null, 
        this.id, 
        nameModifiedValue, 
        this.numbers, 
        this.comment));
  }
  
  /**
   * Copy current immutable object with elements that replace content of {@link ValueObject#numbers()}.
   * @param numbersElements iterable of numbers elements to add
   * @return modified copy of the {@code this} object
   */
  public ImmutableValueObject withNumbers(Iterable<? extends Number> numbersElements) {
    ImmutableList<Number> numbersModifiedValue = ImmutableList.copyOf(numbersElements);
    return checkPreconditions(new ImmutableValueObject(
        (Void) null, 
        this.id, 
        this.name, 
        numbersModifiedValue, 
        this.comment));
  }
  
  /**
   * Copy current immutable object by setting present value for optional {@link ValueObject#comment()}.
   * @param comment value for comment, non-null
   * @return modified copy of the {@code this} object
   */
  public ImmutableValueObject withComment(String comment) {
    Optional<String> commentModifiedValue = Optional.of(comment);
    return checkPreconditions(new ImmutableValueObject(
        (Void) null, 
        this.id, 
        this.name, 
        this.numbers, 
        commentModifiedValue));
  }
  
  /**
   * Copy current immutable object by setting optional value for {@link ValueObject#comment()}.
   * @param comment value for comment, non-null
   * @return modified copy of the {@code this} object
   */
  public ImmutableValueObject withComment(Optional<String> comment) {
    Optional<String> commentModifiedValue = Preconditions.checkNotNull(comment);
    return checkPreconditions(new ImmutableValueObject(
        (Void) null, 
        this.id, 
        this.name, 
        this.numbers, 
        commentModifiedValue));
  }
  
  @Override
  public long id() {
    return id;
  }
  
  @Override
  public String name() {
    return name;
  }
  
  @Override
  public ImmutableList<Number> numbers() {
    return numbers;
  }
  
  @Override
  public Optional<String> comment() {
    return comment;
  }
  
  @Override
  public boolean equals(Object another) {
    return this == another
        || (another instanceof ImmutableValueObject && equalTo((ImmutableValueObject) another));
  }
  
  private boolean equalTo(ImmutableValueObject another) {
    return true
          && id == another.id
          && name.equals(another.name)
          && numbers.equals(another.numbers)
          && comment.equals(another.comment);
  }
  
  private int computeHashCode() {
    int h = 31;
    h = h * 17 + Longs.hashCode(id);
    h = h * 17 + name.hashCode();
    h = h * 17 + numbers.hashCode();
    h = h * 17 + comment.hashCode();
    return h;
  }
  
  @Override
  public int hashCode() {
    return computeHashCode();
  }
  
  @Override
  public String toString() {
    return Objects.toStringHelper("ValueObject")
        .add("id", id)
        .add("name", name)
        .add("numbers", numbers)
        .add("comment", comment)
        .toString();
  }

  /**
   * Creates builder for {@link ValueObject}.
   * @return new ValueObject builder
   */
  public static Builder builder() {
    return new Builder();
  }
  
  /**
   * Builds instances of {@link ValueObject}.
   * Builder is not thread safe and generally should not be stored in fields and collections, 
   * but used immediately to create instances.
   */
  @NotThreadSafe
  public static final class Builder {
    private static final String REQUIRED_ATTRIBUTE =
        "Cannot build ValueObject: required attribute '%s' is not set";
  
    private long id;
    private boolean idIsSet;
    @Nullable  
    private String name;
    private ImmutableList.Builder<Number> numbersBuilder =
        ImmutableList.builder();
    private Optional<String> comment = Optional.absent();
  
    private Builder() {
    }
  
    /**
     * Adjust builder with values from provided {@link ValueObject} instance.
     * Absent optional values will not be copied (will not override current).
     * Collection elements will be added, not replaced.
     * @param fromInstance instance to copy values from
     * @return {@code this} builder for chained invocation
     */
    public Builder copy(ValueObject fromInstance) {
      Preconditions.checkNotNull(fromInstance);
      id(fromInstance.id());
      name(fromInstance.name());
      addAllNumbers(fromInstance.numbers());
      Optional<String> optionalComment = fromInstance.comment();
      if (optionalComment.isPresent()) {
        comment = optionalComment;
      }
      return this;
    }
    
    /**
     * Initializes value for {@link ValueObject#id()}.
     * @param id value for id, non-null
     * @return {@code this} builder for chained invocation
     */
    public Builder id(long id) {
      this.id = id;
      idIsSet = true;
      return this;
    }
    
    /**
     * Initializes value for {@link ValueObject#name()}.
     * @param name value for name, non-null
     * @return {@code this} builder for chained invocation
     */
    public Builder name(String name) {
      this.name = Preconditions.checkNotNull(name);
      return this;
    }
  
    /**
     * Adds one element to {@link ValueObject#numbers()} list.
     * @param numbersElement single numbers element
     * @return {@code this} builder for chained invocation
     */
    public Builder addNumbers(Number numbersElement) {
      numbersBuilder.add(numbersElement);
      return this;
    }

    /**
     * Adds elements to {@link ValueObject#numbers()} list.
     * @param numbersElements iterable of numbers elements
     * @return {@code this} builder for chained invocation
     */
    public Builder addAllNumbers(Iterable<? extends Number> numbersElements) {
      numbersBuilder.addAll(numbersElements);
      return this;
    }
  
    /**
     * Initializes present value for optional {@link ValueObject#comment()}.
     * @param comment value for comment, non-null
     * @return {@code this} builder for chained invocation
     */
    public Builder comment(String comment) {
      this.comment(Optional.of(comment));
      return this;
    }
    
    /**
     * Initializes optional value for {@link ValueObject#comment()}.
     * @param comment value for comment, non-null
     * @return {@code this} builder for chained invocation
     */
    public Builder comment(Optional<String> comment) {
      this.comment = Preconditions.checkNotNull(comment);
      return this;
    }
    
    /**
     * Builds new {@link ValueObject}.
     * @return immutable instance of ValueObject
     */
    public ImmutableValueObject build() {
      Preconditions.checkState(idIsSet, REQUIRED_ATTRIBUTE, "id");
      Preconditions.checkState(name != null, REQUIRED_ATTRIBUTE, "name");
      return checkPreconditions(new ImmutableValueObject(this));
    }
  }
}
```
