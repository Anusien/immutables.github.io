---
title: 'Sample generated code'
layout: page
---

Here's an illustration of what kind of code is being generated by annotation processor.

### Value

```java
import com.google.common.base.Optional;
import java.util.List;
import org.immutables.annotation.GenerateImmutable;

@GenerateImmutable
interface Value {
  long id();
  String name();
  List<Number> numbers();
  Optional<String> comment();
}
```

### ImmutableValue

```java

import com.google.common.base.MoreObjects;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.primitives.Longs;
import javax.annotation.Generated;
import javax.annotation.Nullable;
import javax.annotation.ParametersAreNonnullByDefault;
import javax.annotation.concurrent.Immutable;
import javax.annotation.concurrent.NotThreadSafe;

/**
 * Immutable implementation of {@link Value}.
 * <p>
 * Use static static factory methods to create instances: {@code of()} or
 * {@code builder()}.
 */
@SuppressWarnings("all")
@ParametersAreNonnullByDefault
@Generated({"immutable.tjs", "Value"})
@Immutable
final class ImmutableValue
    implements Value {

  private static ImmutableValue checkPreconditions(ImmutableValue instance) {
    return instance;
  }

  private final ImmutableList<Number> numbers;
  private final String name;
  private final Optional<String> comment;
  private final long id;

  private ImmutableValue(Builder builder) {
    this.numbers = builder.numbersBuilder.build();
    this.name = builder.name;
    this.comment = builder.comment;
    this.id = builder.id;
  }

  private ImmutableValue(
      ImmutableValue copiedInstance, 
      ImmutableList<Number> numbers, String name, Optional<String> comment, long id) {
    this.numbers = numbers;
    this.name = name;
    this.comment = comment;
    this.id = id;
  }
  
  /**
   * Copy current immutable object with elements that replace content of {@link Value#numbers()}.
   * Shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
   * @param numbersElements iterable of numbers elements to add
   * @return modified copy of the {@code this} object
   */
  public ImmutableValue withNumbers(Iterable<? extends Number> numbers) {
    if (this.numbers == numbers) {
      return this;
    }
    ImmutableList<Number> numbersModifiedValue = ImmutableList.copyOf(numbers);
    return checkPreconditions(new ImmutableValue(
        this, 
        numbersModifiedValue, 
        this.name, 
        this.comment, 
        this.id));
  }
    
  /**
   * Copy current immutable object by setting value for {@link Value#name()}.
   * Shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
   * @param name value for name, non-null
   * @return modified copy of the {@code this} object
   */
  public ImmutableValue withName(String name) {
    if (this.name == name) {
      return this;
    }
    String nameModifiedValue = Preconditions.checkNotNull(name);
    return checkPreconditions(new ImmutableValue(
        this, 
        this.numbers, 
        nameModifiedValue, 
        this.comment, 
        this.id));
  }
  
  /**
   * Copy current immutable object by setting present value for optional {@link Value#comment()}.
   * @param comment value for comment, non-null
   * @return modified copy of the {@code this} object
   */
  public ImmutableValue withComment(String comment) {
    Optional<String> commentModifiedValue = Optional.of(comment);
    return checkPreconditions(new ImmutableValue(
        this, 
        this.numbers, 
        this.name, 
        commentModifiedValue, 
        this.id));
  }
  
  /**
   * Copy current immutable object by setting optional value for {@link Value#comment()}.
   * Shallow reference equality check on optional value is used to prevent copying of the same value by returning {@code this}.
   * @param comment value for comment, non-null
   * @return modified copy of the {@code this} object
   */
  public ImmutableValue withComment(Optional<String> comment) {
    if (this.comment == comment) {
      return this;
    }
    Optional<String> commentModifiedValue = Preconditions.checkNotNull(comment);
    return checkPreconditions(new ImmutableValue(
        this, 
        this.numbers, 
        this.name, 
        commentModifiedValue, 
        this.id));
  }
    
  /**
   * Copy current immutable object by setting value for {@link Value#id()}.
   * Value equality check is used to prevent copying of the same value by returning {@code this}.
   * @param id value for id, non-null
   * @return modified copy of the {@code this} object
   */
  public ImmutableValue withId(long id) {
    if (this.id == id) {
      return this;
    }
    long idModifiedValue = id;
    return checkPreconditions(new ImmutableValue(
        this, 
        this.numbers, 
        this.name, 
        this.comment, 
        idModifiedValue));
  }
  
  @Override
  public ImmutableList<Number> numbers() {
    return numbers;
  }
  
  @Override
  public String name() {
    return name;
  }
  
  @Override
  public Optional<String> comment() {
    return comment;
  }
  
  @Override
  public long id() {
    return id;
  }
  
  @Override
  public boolean equals(Object another) {
    return this == another
        || (another instanceof ImmutableValue && equalTo((ImmutableValue) another));
  }
  
  private boolean equalTo(ImmutableValue another) {
    return true
          && numbers.equals(another.numbers)
          && name.equals(another.name)
          && comment.equals(another.comment)
          && id == another.id;
  }
  
  private int computeHashCode() {
    int h = 31;
    h = h * 17 + numbers.hashCode();
    h = h * 17 + name.hashCode();
    h = h * 17 + comment.hashCode();
    h = h * 17 + Longs.hashCode(id);
    return h;
  }
  
  @Override
  public int hashCode() {
    return computeHashCode();
  }
  
  @Override
  public String toString() {
    return MoreObjects.toStringHelper(this)
        .add("numbers", numbers())
        .add("name", name())
        .add("comment", comment())
        .add("id", id())
        .toString();
  }

  /**
   * Creates builder for {@link Value}.
   * @return new Value builder
   */
  public static Builder builder() {
    return new Builder();
  }
  
  /**
   * Builds instances of {@link Value}.
   * Builder is not thread safe and generally should not be stored in fields and collections, 
   * but used immediately to create instances.
   */
  @NotThreadSafe
  static final class Builder {
    private static final String REQUIRED_ATTRIBUTE =
        "Cannot build Value: required attribute '%s' is not set";
  
    private ImmutableList.Builder<Number> numbersBuilder =
        ImmutableList.builder();
    @Nullable  
    private String name;
    private Optional<String> comment = Optional.absent();
    private long id;
    private boolean idIsSet;
  
    private Builder() {
    }
  
    /**
     * Adjust builder with values from provided {@link Value} instance.
     * Absent optional values will not be copied (will not override current).
     * Collection elements will be added, not replaced.
     * @param fromInstance instance to copy values from
     * @return {@code this} builder for chained invocation
     */
    public Builder copy(Value fromInstance) {
      Preconditions.checkNotNull(fromInstance);
      addAllNumbers(fromInstance.numbers());
      name(fromInstance.name());
      Optional<String> optionalComment = fromInstance.comment();
      if (optionalComment.isPresent()) {
        comment = optionalComment;
      }
      id(fromInstance.id());
      return this;
    }
  
    /**
     * Adds one element to {@link Value#numbers()} list.
     * @param numbersElement single numbers element
     * @return {@code this} builder for chained invocation
     */
    public Builder addNumbers(Number numbersElement) {
      numbersBuilder.add(numbersElement);
      return this;
    }
  
    /**
     * Adds elements to {@link Value#numbers()} list.
     * @param numbersElements iterable of numbers elements
     * @return {@code this} builder for chained invocation
     */
    public Builder addAllNumbers(Iterable<? extends Number> numbersElements) {
      numbersBuilder.addAll(numbersElements);
      return this;
    }
    
    /**
     * Initializes value for {@link Value#name()}.
     * @param name value for name, non-null
     * @return {@code this} builder for chained invocation
     */
    public Builder name(String name) {
      this.name = Preconditions.checkNotNull(name);
      return this;
    }
  
    /**
     * Initializes present value for optional {@link Value#comment()}.
     * @param comment value for comment, non-null
     * @return {@code this} builder for chained invocation
     */
    public Builder comment(String comment) {
      this.comment(Optional.of(comment));
      return this;
    }
    
    /**
     * Initializes optional value for {@link Value#comment()}.
     * @param comment value for comment, non-null
     * @return {@code this} builder for chained invocation
     */
    public Builder comment(Optional<String> comment) {
      this.comment = Preconditions.checkNotNull(comment);
      return this;
    }
    
    /**
     * Initializes value for {@link Value#id()}.
     * @param id value for id, non-null
     * @return {@code this} builder for chained invocation
     */
    public Builder id(long id) {
      this.id = id;
      idIsSet = true;
      return this;
    }
    
    /**
     * Builds new {@link Value}.
     * @return immutable instance of Value
     */
    public ImmutableValue build() {
      Preconditions.checkState(name != null, REQUIRED_ATTRIBUTE, "name");
      Preconditions.checkState(idIsSet, REQUIRED_ATTRIBUTE, "id");
      return checkPreconditions(new ImmutableValue(this));
    }
  }
}
```
